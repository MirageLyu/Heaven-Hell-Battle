
# Java - FinalProject..



<center> 脚曳铁履忾犯边，</center>



<center> 踏经卧躯勇向前。 </center>



<center> 实为太平融融日， </center>



<center> 地漫胭脂枉旧年。 </center>



<center> ... </center>



## 项目介绍

### 背景

红：蝎子精下来战书，约我等明日决战...如何对敌？

老爷爷：孩子，~~明日老夫只需一席话语~~（误）创世者为你们赋予了战斗的能力，为你们绘制的战场，为你们烙印了正义的象征，是时候展现你们真正的技术了！你们在做，老天也在看，他会将你们的事迹记录下来，流传下去，为后世传颂！

七人：爷爷可到阵前助阵，到时自见分晓！

......

### 基本介绍

本实验以之前的代码为基础，主要添加了多线程机制以实现各生物自动战斗，死亡结算与物品掉落机制，存档读档机制。

#### 开发环境

|         OS          |         IDE          | JDK Version | Maven Version |
| :-----------------: | :------------------: | :---------: | :-----------: |
|     Windows 10      | IntelliJ IDEA 2018.2 |     1.8     |     3.5.4     |
| Mac-OS 10.14 Mojave | IntelliJ IDEA 2018.3 |     1.8     |     3.5.4     |

#### 界面与功能介绍

![1](https://github.com/MirageLyu/Heaven-Hell-Battle/blob/master/img/1.png)

界面核心部分是一个10*20的矩阵空间，每一个位置可以放置一个生物，或一个物品（后面说）。旁边有两个按钮，点击Start，将根据默认阵法开始战斗；点击Load，可以从本地文件中，选择.slog文件加载存档，重现之前的战斗情形。

#### 战斗机制介绍

##### 死亡结算

生物阵亡后，这里不是留下一个占位的实体，而是在阵亡位置留下一个掉落物品。当同阵营的生物使用了物品后，会获得生命值或攻击力上的提升，反之，则受到相应的伤害。

##### 属性

每个生物具有以下属性

- 生命值
- 攻击力
- 攻击范围
- 阵营

每个物品具有以下属性

- 生命值 & 攻击力
- 阵营

##### 运动与攻击逻辑

无论何时，如果生物的攻击范围内有敌对生物，即向其攻击。

当生物的生命值大于50%时，他会主动寻找距离他最近的敌对阵营的生物，并向其攻击；如果生命值不大于50%时，其会寻找距离其最近的本阵营的掉落物品，意为先使用了物品，再归来战斗。

发动攻击的同时，也可以按上述的逻辑移动。这样就避免了拥挤排队的情形。

#### 存档机制介绍

存档机制采用类似于帧动画的机制，即每隔一段时间，保存当前UI上的信息，即为一帧；将整场战斗所有的帧保存下来，即保存了整场战斗。读档时，将所有的帧读出来，再逐帧播放，即可还原战斗过程。

---

### 项目设计

#### 实体设计

实体包括生物和物品，生物又包括葫芦娃、老爷爷、蝎子精等等。

![2](https://github.com/MirageLyu/Heaven-Hell-Battle/blob/master/img/2.png)

这些实体中定义了一系列的方法，以满足其他特性的实现：

##### 物品的使用

仅提供一个公共方法（除get,set外，下同）：beUsed(Creature creature)，供生物实体调用。将物品自身的的属性附加到生物对象身上。

##### 战斗需要

提供了移动方法，供线程中调用；

提供了攻击与被攻击的公共方法；

提供了死亡判定的公共方法。

##### 实例数量的控制

因为世界上，老爷爷、蝎子精、蛇精都只能有一个，而且葫芦娃只能有7个。这里通过一个static变量，记录对象产生的数量，并在构造器中对数量进行判断，从而达到了对实例数量的控制。

##### 如何辨识不同实体

每一个实体都有一个独一无二的域：identifier，它唯一地表示了每一种实例。这为之后的UI展示、读存档、以及一些判定逻辑提供了基础。

#### 战场类设计

战场类中提供了诸多功能，而且每个功能实现许多的方法。

战场中维护了一个Being矩阵，并维护了在场存活的两个阵营的生物，以及在场物品的队列，供判断生物判断最近实体，判断射程范围，以及战争结束判定等使用。

##### 阵型设定方法

![3](https://github.com/MirageLyu/Heaven-Hell-Battle/blob/master/img/3.png)

实现了8种阵型，boolean参数的含义为，判断将阵型部署在左侧还是右侧。

##### 战争结束判定

![4](https://github.com/MirageLyu/Heaven-Hell-Battle/blob/master/img/4.png)

该方法判断了战争是否结束。其逻辑即：一旦两个阵营的存活队列有空的，即为战争结束。



#### 亮点：Dictionary 与 Configuration

本项目中，将许多属性、常量独立出来，而不是写死在代码中。这为之后修改一些属性值等提供了便利。

![5](https://github.com/MirageLyu/Heaven-Hell-Battle/blob/master/img/5.png)

这三个Dict，可以获取实体的identifier，以及根据identifier获取图片，通过葫芦娃的排序获取名字。这些值若之后有修改，将非常便利。

![6](https://github.com/MirageLyu/Heaven-Hell-Battle/blob/master/img/6.png)

在Configuration类中，将许多数值独立出来，使得其易于修改。（拓展：这里还考虑到实现配置文件，每次程序初始化时读入数据。可行，但并未实现）。

#### 存档 & 读档 设计

##### 帧

观察UI，我们想要还原一个时间点战场上的情景，需要记录：图片、最大血量、当前血量。因此一个帧就包括以上三个矩阵，记录整个战场的情况。

如何将实体矩阵转成一个帧当中记录的信息？通过一个ShowBeing接口。这个接口中声明了以下方法：

![7](https://github.com/MirageLyu/Heaven-Hell-Battle/blob/master/img/7.png)

并为Being类附加上ShowBeing接口。这样，就实现了从Being矩阵到帧的转换。

##### 回放类

这个类中提供了回放功能的所有接口，包括存档（输出到文件），读档（读入文件），逐帧展示。当点击Load按钮并选择了存档文件之后，即创建一个新线程，每隔一段时间（2s）逐帧播放，直到所有的帧都播放完毕。

#### 线程设计

本程序的线程主要包括以下：

- 每个生物的运动与攻击线程 —— 当死亡时结束
- 主线程，判断战斗是否结束
- GUI刷新线程，每隔一段时间，根据后台的矩阵数据刷新
- 回放：逐帧播放线程

其中，GUI刷新线程和主线程和回放线程之间有共享资源：ShowBeing矩阵。所以在各线程中访问该矩阵时，要加锁。这里通过同步语句块来实现。

#### 补充一些

每次执行该程序，只可进行一次战斗，即按钮Start只可以点击一次，之后会失效。且当战斗中，或回放中，两个按钮都会失效，当前任务结束后，Load按钮会恢复可用，可以再次读档播放。

---



##  部分实现细节

#### 异常处理

前面提到，每种生物都有其数量上限，当达到上限之后，再尝试创建对象，应该抛出异常。这里实现了CreateFailedException。

```java
public class CreateFailedException extends Exception{
    public CreateFiledException(String s){
        super(s);
    }
    public void printErrorMessage(){
        Output.outputCreateFailedMessage(this.getMessage());
    }
}
```

#### 命令行打印信息规范

这里将几乎整个项目中所有的需要在命令行打印信息，以供判断运行情况与调试的输出语句独立出来，封装了一个Output类，里面提供了诸多静态方法。这样在调试时，会节省大量时间，而且在运行时也可以看到后台程序的行为。上面异常处理代码中的Output即为其中一个方法。

#### 序列化实现读档存档

一个存档的基本单位是帧，一个存档由多个帧组成。而序列化是针对对象的，所以我将帧Frame放到LinkedList中，再封装成一个MultiFrame，再在Replay中将MultiFrame序列化。

这里意识到了一个问题：似乎发现了一个除了new之外，产生对象的方式（虽然之前也是new出来的）。

使用LinkedList，是因为其可以像队列一样使用，这与逐帧播放的理念是一致的，帧要先进先出。



## 不足与展望

- 设计模式应用不够完善，一些类之前耦合较高。
- 程序趣味性匮乏，需要添加动画、音乐，以及更多的交互。
- 等等...
